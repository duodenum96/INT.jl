<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Autocorrelation Windows · IntrinsicTimescales.jl</title><meta name="title" content="Autocorrelation Windows · IntrinsicTimescales.jl"/><meta property="og:title" content="Autocorrelation Windows · IntrinsicTimescales.jl"/><meta property="twitter:title" content="Autocorrelation Windows · IntrinsicTimescales.jl"/><meta name="description" content="Documentation for IntrinsicTimescales.jl."/><meta property="og:description" content="Documentation for IntrinsicTimescales.jl."/><meta property="twitter:description" content="Documentation for IntrinsicTimescales.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../home/">IntrinsicTimescales.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../home/">Getting Started</a></li><li><a class="tocitem" href="../practice_intro/">Practice</a></li><li><a class="tocitem" href="../../theory/theory/">Theory</a></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../../acw/">Model-Free Timescale Estimation</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Simulation Based Timescale Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simbasedinference/">Overview</a></li><li><a class="tocitem" href="../../one_timescale/">One Timescale Model</a></li><li><a class="tocitem" href="../../one_timescale_with_missing/">One Timescale Model with Missing Data</a></li><li><a class="tocitem" href="../../one_timescale_and_osc/">One Timescale Model with Oscillations</a></li><li><a class="tocitem" href="../../one_timescale_and_osc_with_missing/">One Timescale Model with Oscillations and Missing Data</a></li><li><a class="tocitem" href="../../fit_parameters/">Model Fitting and Parameters</a></li><li><a class="tocitem" href="../../fit_result/">Results</a></li></ul></li></ul></li><li><a class="tocitem" href="../../">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Autocorrelation Windows</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Autocorrelation Windows</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/master/docs/src/practice/practice_2_acw.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Autocorrelation-Windows"><a class="docs-heading-anchor" href="#Autocorrelation-Windows">Autocorrelation Windows</a><a id="Autocorrelation-Windows-1"></a><a class="docs-heading-anchor-permalink" href="#Autocorrelation-Windows" title="Permalink"></a></h1><p>We finished the <a href="../practice_1_acf/">previous section</a> with a discussion about how a determinstic statistic can be influenced by the limitations of our data. In this section, we will generalize the problem and discuss various autocorrelation window (ACW) types. </p><p>First, some nomenclature. When we make an analysis on the data, for example, calculate event-related potentials, ACWs and so on, we are aiming for an <em>estimand</em>. In event-related potentials, our estimand is the stereotypical response of the brain to some cognitive task. In ACWs, our estimand is intrinsic neural timescales (INTs). The ACW we get is not INT per se, it is the <em>estimate</em> of INT. To obtain the estimate, we use an <em>estimator</em>. The schema below shows the relationship. </p><p><img src="../assets/practice_2_estimator.drawio.svg" alt/></p><p>Our first note about the noise of estimators was the finiteness of the data. We noted that as we go along further lags, we have less data points at our hand to calculate the correlation values, making the estimate noisier. A first response to the problem is to use a different cutoff. Instead of waiting the autocorrelation function to reach exactly to 0 thus completely losing the similarity, we can cut it off when it reaches 0.5 and say losing half of the similarity. After all, a time-series with a longer timescale should take longer to lose half of it. This method is called ACW-50. It is  older than ACW-0. To my knowledge, used first in <a href="https://pubmed.ncbi.nlm.nih.gov/23083743/">Honey et al., 2012</a>. This was a time when the phrase intrinsic neural timescale had not been established. The term at that time was temporal receptive windows (TRW). I will discuss the evolution of the term more in the [Theory] section. For now, we will make simulations from two processes with different timescales and see how well we can distinguish their INTs using ACW-50 versus ACW-0. To quickly get many simulations with the same timescale, I will set num_trials to 1000. </p><pre><code class="language-julia hljs">using IntrinsicTimescales # import IntrinsicTimescales package
using Random 
using Plots # to plot the results
Random.seed!(1) # for replicability

timescale_1 = 1.0
timescale_2 = 3.0
sd = 1.0 # sd of data we&#39;ll simulate
dt = 0.001 # Time interval between two time points
duration = 10.0 # 10 seconds of data
num_trials = 1000 # Number of trials

data_1 = generate_ou_process(timescale_1, sd, dt, duration, num_trials)
data_2 = generate_ou_process(timescale_2, sd, dt, duration, num_trials)
println(size(data_1)) # == 30, 1000: 30 trials and 10000 time points</code></pre><p>To streamline the ACW calculation, I will use the <a href="../../acw/"><code>acw</code></a> function from INT.jl. This function takes your time series data,  sampling rate and ACW types you want to calculate and returns the ACW values in the same shape of the data. Along with ACW results it also returns additional information that will be useful later. To extract ACW values, we will extract the field <code>acw_results</code> from the output of <code>acw</code>. It is best to demonstrate with an example. </p><pre><code class="language-julia hljs">fs = 1 / dt # sampling rate
acwresults_1 = acw(data_1, fs, acwtypes=[:acw50, :acw0]) 
acwresults_2 = acw(data_2, fs, acwtypes=[:acw50, :acw0])
# Since we used the order [:acw50, :acw0], the first element of results is ACW-50, the second is ACW-0.
acw50_1 = acwresults_1.acw_results[1]
acw0_1 = acwresults_1.acw_results[2]
acw50_2 = acwresults_2.acw_results[1]
acw0_2 = acwresults_2.acw_results[2]</code></pre><p>How to quantify the sensitivity of the estimator (to changes in the timescale)? Let&#39;s assume an experimental scenario where we are comparing INTs of two conditions or two groups. We are calculating one timescale from each condition. The number of trials (<code>num_trials</code> above) can refer to either number of trials or subjects. Then we&#39;ll compare the INTs from two groups. We know for a fact that first condition has a shorter timescale than the second since we set them ourselves in the code above (<code>timescale_1</code> and <code>_2</code>). We will calculate what percentage of the time we are wrong, that we are getting a longer INT for the first condition and a shorter INT for the second condition. </p><p>Take a look at the code below, we will calculate what I described in the previous awful paragraph. Hopefully the code is cleaner than my English. Additionally, we will plot histograms to visualize the overlap between estimates. </p><pre><code class="language-julia hljs">using Printf

bad_acw50_timescale = mean(acw50_2 .&lt;= acw50_1) * 100
bad_acw0_timescale = mean(acw0_2 .&lt;= acw0_1) * 100

# Plot histograms
p1 = histogram(acw50_1, alpha=0.5, label=&quot;timescale 1 = $(timescale_1)&quot;)
histogram!(p1, acw50_2, alpha=0.5, label=&quot;timescale 2 = $(timescale_2)&quot;)
# Plot the median since distributions are not normal
vline!(p1, [median(acw50_1), median(acw50_2)], linewidth=3, color=:black, label=&quot;&quot;) 
title!(p1, &quot;ACW-50\n&quot;)
# Mad string manipulation
annotate!(p1, 1, 100, 
    (@sprintf(&quot;Proportion of \&quot;wrong\&quot; timescale \nestimates: %.2f%% \n&quot;, bad_acw50_timescale)), textfont=font(24), :left)
# ACW-0
p2 = histogram(acw0_1, alpha=0.5, label=&quot;timescale 1 = $(timescale_1)&quot;)
histogram!(p2, acw0_2, alpha=0.5, label=&quot;timescale 2 = $(timescale_2)&quot;)

vline!(p2, [median(acw0_1), median(acw0_2)], linewidth=3, color=:black, label=&quot;&quot;)
title!(p2, &quot;ACW-0\n&quot;)
annotate!(p2, 2, 175, 
    (@sprintf(&quot;Proportion of \&quot;wrong\&quot; timescale \nestimates: %.2f%% \n&quot;, bad_acw0_timescale)), textfont=font(24), :left)
plot(p1, p2, size=(1600, 800))</code></pre><p><img src="../assets/practice_2_1.svg" alt/></p><p>It seems ACW-0 gives messier results. Needless to say, these results depend on the difference between real timescales and the amount of data. Feel free to change these parameters and investigate the results under different scenarios. So ACW-50 seems to be a better estimator at least in the setting we specified above. Is our work done then? First of all, we used a weird way to define &quot;wrong&quot;. We&#39;ve reduced the correctness to a binary choice of is something greater or smaller than other. We can be more principled than this and actually quantify how much we are off. We will do this in a minute. For now, let&#39;s consider another scenario. In the example above, we had <code>dt</code> = 0.001 implying our sampling rate (<code>fs</code>) is 1000 Hz and we have 10 seconds of data. This sounds like an EEG/MEG scenario. Let&#39;s try an fMRI scenario where we have a sampling rate of 0.5 Hz (corresponding TR=2 seconds) and 300 seconds of data. We&#39;ll set the timescales to 1 seconds and 3 seconds for short timescale and long timescale guys. </p><pre><code class="language-julia hljs">timescale_1 = 1.0
timescale_2 = 3.0
sd = 1.0 
dt = 2.0 # Time interval between two time points
duration = 300.0 # 5 minutes of data
num_trials = 1000 # Number of trials

data_1 = generate_ou_process(timescale_1, sd, dt, duration, num_trials)
data_2 = generate_ou_process(timescale_2, sd, dt, duration, num_trials)

fs = 1 / dt # sampling rate
acwresults_1 = acw(data_1, fs, acwtypes=[:acw50, :acw0]) 
acwresults_2 = acw(data_2, fs, acwtypes=[:acw50, :acw0])
acw50_1 = acwresults_1.acw_results[1]
acw0_1 = acwresults_1.acw_results[2]
acw50_2 = acwresults_2.acw_results[1]
acw0_2 = acwresults_2.acw_results[2]

bad_acw50_timescale = mean(acw50_2 .&lt;= acw50_1) * 100
bad_acw0_timescale = mean(acw0_2 .&lt;= acw0_1) * 100

# Plot histograms
p1 = histogram(acw50_1, alpha=0.5, label=&quot;timescale 1 = $(timescale_1)&quot;)
histogram!(p1, acw50_2, alpha=0.5, label=&quot;timescale 2 = $(timescale_2)&quot;)
vline!(p1, [median(acw50_1), median(acw50_2)], linewidth=3, color=:black, label=&quot;&quot;) 
title!(p1, &quot;ACW-50\n&quot;)
annotate!(p1, 1, 100, 
    (@sprintf(&quot;Proportion of \&quot;wrong\&quot; timescale \nestimates: %.2f%% \n&quot;, bad_acw50_timescale)), textfont=font(24), :left)
# ACW-0
p2 = histogram(acw0_1, alpha=0.5, label=&quot;timescale 1 = $(timescale_1)&quot;)
histogram!(p2, acw0_2, alpha=0.5, label=&quot;timescale 2 = $(timescale_2)&quot;)

vline!(p2, [median(acw0_1), median(acw0_2)], linewidth=3, color=:black, label=&quot;&quot;)
title!(p2, &quot;ACW-0\n&quot;)
annotate!(p2, 2, 175, 
    (@sprintf(&quot;Proportion of \&quot;wrong\&quot; timescale \nestimates: %.2f%% \n&quot;, bad_acw0_timescale)), textfont=font(24), :left)
plot(p1, p2, size=(1600, 800))</code></pre><p>Half the time, we got the wrong result with ACW-50! To diagnose the problem, let&#39;s plot the autocorrelation functions. This is where the other information stored in the output of <a href="../../acw/"><code>acw</code></a> comes useful. We&#39;ll use the function <code>acwplot</code> to plot the ACFs. </p><pre><code class="language-julia hljs">acwplot(acwresults_1, only_acf=true)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 13 February 2025 17:34">Thursday 13 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
